/*! \file   janus_streaming.c
 * \author Lorenzo Miniero <lorenzo@meetecho.com>
 * \copyright GNU General Public License v3
 * \brief  Janus Streaming plugin
 * \details Check the \ref streaming for more details.
 *
 * \ingroup plugins
 * \ref plugins
 *
 * \page streaming Streaming plugin documentation
 * This is a streaming plugin for Janus, allowing WebRTC peers
 * to watch/listen to pre-recorded files or media generated by another tool.
 * Specifically, the plugin currently supports three different type of streams:
 *
 * -# on-demand streaming of pre-recorded media files (different
 * streaming context for each peer);
 * -# live streaming of pre-recorded media files (shared streaming
 * context for all peers attached to the stream);
 * -# live streaming of media generated by another tool (shared
 * streaming context for all peers attached to the stream).
 *
 * [Existing documentation omitted for brevity, unchanged from original]
 */

/* [Existing includes unchanged] */
#include "plugin.h"

#include <errno.h>
#include <netdb.h>
#include <sys/poll.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <arpa/inet.h> /* Added for inet_ntoa */

#include <jansson.h>

#ifdef HAVE_LIBCURL
#include <curl/curl.h>
#ifndef CURL_AT_LEAST_VERSION
#define CURL_AT_LEAST_VERSION(x,y,z) 0
#endif
#endif

#ifdef HAVE_LIBOGG
#include <ogg/ogg.h>
#endif

#include "../debug.h"
#include "../apierror.h"
#include "../config.h"
#include "../mutex.h"
#include "../rtp.h"
#include "../rtpsrtp.h"
#include "../rtcp.h"
#include "../record.h"
#include "../utils.h"
#include "../sdp-utils.h"
#include "../ip-utils.h"

/* Default settings */
#define JANUS_STREAMING_DEFAULT_SESSION_TIMEOUT 0
#define JANUS_STREAMING_DEFAULT_RECONNECT_DELAY 5
#define JANUS_STREAMING_DEFAULT_CURL_TIMEOUT 10L
#define JANUS_STREAMING_DEFAULT_CURL_CONNECT_TIMEOUT 5L

/* Plugin information */
#define JANUS_STREAMING_VERSION			10
#define JANUS_STREAMING_VERSION_STRING	"0.0.10"
#define JANUS_STREAMING_DESCRIPTION		"This is a streaming plugin for Janus, allowing WebRTC peers to watch/listen to pre-recorded files or media generated by an external source."
#define JANUS_STREAMING_NAME			"JANUS Streaming plugin"
#define JANUS_STREAMING_AUTHOR			"Meetecho s.r.l."
#define JANUS_STREAMING_PACKAGE			"janus.plugin.streaming"

/* [Existing plugin methods unchanged] */
janus_plugin *create(void);
int janus_streaming_init(janus_callbacks *callback, const char *config_path);
void janus_streaming_destroy(void);
int janus_streaming_get_api_compatibility(void);
int janus_streaming_get_version(void);
const char *janus_streaming_get_version_string(void);
const char *janus_streaming_get_description(void);
const char *janus_streaming_get_name(void);
const char *janus_streaming_get_author(void);
const char *janus_streaming_get_package(void);
void janus_streaming_create_session(janus_plugin_session *handle, int *error);
struct janus_plugin_result *janus_streaming_handle_message(janus_plugin_session *handle, char *transaction, json_t *message, json_t *jsep);
json_t *janus_streaming_handle_admin_message(json_t *message);
void janus_streaming_setup_media(janus_plugin_session *handle);
void janus_streaming_incoming_rtp(janus_plugin_session *handle, janus_plugin_rtp *packet);
void janus_streaming_incoming_rtcp(janus_plugin_session *handle, janus_plugin_rtcp *packet);
void janus_streaming_data_ready(janus_plugin_session *handle);
void janus_streaming_hangup_media(janus_plugin_session *handle);
void janus_streaming_destroy_session(janus_plugin_session *handle, int *error);
json_t *janus_streaming_query_session(janus_plugin_session *handle);

/* [Existing struct definitions, with modification to janus_streaming_mountpoint] */
typedef struct janus_streaming_mountpoint {
    janus_mutex mutex;
    guint64 id;
    char *name;
    char *description;
    janus_streaming_type streaming_type;
    janus_streaming_source streaming_source;
    char *source_ip; /* Source IP of RTP packets */
    int source_port; /* Source port of RTP packets */
    /* ... other fields unchanged ... */
    gboolean is_private;
    char *secret;
    char *pin;
    gboolean enabled;
    gboolean active;
    GList *viewers;
    int helper_threads;
    GList *threads;
    volatile gint destroyed;
    janus_refcount ref;
} janus_streaming_mountpoint;

/* [Other structs unchanged, omitted for brevity] */

/* [Existing functions, with modifications where needed] */

/* Helper function to create RTP source */
static janus_streaming_mountpoint *janus_streaming_create_rtp_source(
        /* ... parameters unchanged ... */) {
    janus_streaming_mountpoint *mp = g_malloc0(sizeof(janus_streaming_mountpoint));
    mp->id = id;
    mp->name = name ? g_strdup(name) : NULL;
    mp->description = description ? g_strdup(description) : NULL;
    mp->streaming_type = janus_streaming_type_rtp;
    mp->streaming_source = janus_streaming_source_rtp;
    mp->source_ip = NULL; /* Initialize source_ip */
    mp->source_port = 0;  /* Initialize source_port */
    /* ... rest of function unchanged ... */
    return mp;
}

/* Helper function to destroy mountpoint */
static void janus_streaming_destroy(janus_streaming_mountpoint *mp) {
    if(mp->name)
        g_free(mp->name);
    if(mp->description)
        g_free(mp->description);
    if(mp->source_ip)
        g_free(mp->source_ip);
    /* ... rest of function unchanged ... */
    g_free(mp);
}

/* Modified relay thread to capture source IP/port */
static void *janus_streaming_relay_thread(void *data) {
    janus_streaming_mountpoint *mountpoint = (janus_streaming_mountpoint *)data;
    janus_streaming_rtp_source *source = (janus_streaming_rtp_source *)mountpoint->source;
    char *name = g_strdup(mountpoint->name ? mountpoint->name : "??");
    JANUS_LOG(LOG_INFO, "[%s] Starting streaming relay thread\n", name);

    /* ... existing setup code unchanged ... */

    while(!g_atomic_int_get(&stopping) && !g_atomic_int_get(&mountpoint->destroyed)) {
        /* ... existing poll setup unchanged ... */
        resfd = poll(fds, num, 1000);
        if(resfd < 0) {
            /* ... error handling unchanged ... */
        } else if(resfd == 0) {
            continue;
        }
        int i = 0;
        for(i=0; i<num; i++) {
            if(fds[i].revents & (POLLERR | POLLHUP)) {
                /* ... error handling unchanged ... */
            } else if(fds[i].revents & POLLIN) {
                if(fds[i].fd == source->pipefd[0]) {
                    /* ... pipe handling unchanged ... */
                } else {
                    stream = g_hash_table_lookup(source->media_byfd, GINT_TO_POINTER(fds[i].fd));
                }
                if(stream == NULL) {
                    struct sockaddr_in addr;
                    socklen_t addrlen = sizeof(addr);
                    (void)recvfrom(fds[i].fd, buffer, 1500, 0, (struct sockaddr *)&addr, &addrlen);
                    continue;
                }
                if(stream->type == JANUS_STREAMING_MEDIA_AUDIO && fds[i].fd == stream->fd[0]) {
                    if(mountpoint->active == FALSE)
                        mountpoint->active = TRUE;
                    gint64 now = janus_get_monotonic_time();
#ifdef HAVE_LIBCURL
                    source->reconnect_timer = now;
#endif
                    struct sockaddr_in addr;
                    socklen_t addrlen = sizeof(addr);
                    bytes = recvfrom(fds[i].fd, buffer, 1500, 0, (struct sockaddr *)&addr, &addrlen);
                    if(bytes > 0 && janus_is_rtp(buffer, bytes)) {
                        janus_mutex_lock(&mountpoint->mutex);
                        char *new_ip = inet_ntoa(addr.sin_addr);
                        int new_port = ntohs(addr.sin_port);
                        if(mountpoint->source_ip == NULL || strcmp(mountpoint->source_ip, new_ip) != 0) {
                            g_free(mountpoint->source_ip);
                            mountpoint->source_ip = g_strdup(new_ip);
                        }
                        mountpoint->source_port = new_port;
                        janus_mutex_unlock(&mountpoint->mutex);
                    }
                    /* ... rest of audio handling unchanged ... */
                } else if(stream->type == JANUS_STREAMING_MEDIA_VIDEO && ((fds[i].fd == stream->fd[0]) ||
                        (fds[i].fd == stream->fd[1]) || (fds[i].fd == stream->fd[2]))) {
                    int index = -1;
                    if(fds[i].fd == stream->fd[0])
                        index = 0;
                    else if(fds[i].fd == stream->fd[1])
                        index = 1;
                    else if(fds[i].fd == stream->fd[2])
                        index = 2;
                    if(mountpoint->active == FALSE)
                        mountpoint->active = TRUE;
                    gint64 now = janus_get_monotonic_time();
#ifdef HAVE_LIBCURL
                    source->reconnect_timer = now;
#endif
                    struct sockaddr_in addr;
                    socklen_t addrlen = sizeof(addr);
                    bytes = recvfrom(fds[i].fd, buffer, 1500, 0, (struct sockaddr *)&addr, &addrlen);
                    if(bytes > 0 && janus_is_rtp(buffer, bytes)) {
                        janus_mutex_lock(&mountpoint->mutex);
                        char *new_ip = inet_ntoa(addr.sin_addr);
                        int new_port = ntohs(addr.sin_port);
                        if(mountpoint->source_ip == NULL || strcmp(mountpoint->source_ip, new_ip) != 0) {
                            g_free(mountpoint->source_ip);
                            mountpoint->source_ip = g_strdup(new_ip);
                        }
                        mountpoint->source_port = new_port;
                        janus_mutex_unlock(&mountpoint->mutex);
                    }
                    /* ... rest of video handling unchanged ... */
                } else if(stream->type == JANUS_STREAMING_MEDIA_DATA && fds[i].fd == stream->fd[0]) {
                    /* ... data handling unchanged ... */
                } else if(fds[i].fd == stream->rtcp_fd) {
                    /* ... RTCP handling unchanged ... */
                }
            }
        }
    }

    /* ... cleanup code unchanged ... */
    JANUS_LOG(LOG_VERB, "[%s] Leaving streaming relay thread\n", name);
    g_free(name);
    janus_refcount_decrease(&mountpoint->ref);
    return NULL;
}

/* Modified handle_message to include source_ip and source_port in list response */
struct janus_plugin_result *janus_streaming_handle_message(janus_plugin_session *handle, char *transaction, json_t *message, json_t *jsep) {
    /* ... existing code unchanged ... */
    const char *request_text = json_string_value(json_object_get(message, "request"));
    if(!strcasecmp(request_text, "list")) {
        json_t *list = json_array();
        GHashTableIter iter;
        gpointer value;
        g_hash_table_iter_init(&iter, mountpoints);
        while(g_hash_table_iter_next(&iter, NULL, &value)) {
            janus_streaming_mountpoint *mp = value;
            if(mp->is_private)
                continue;
            json_t *ml = json_object();
            json_object_set_new(ml, "id", json_integer(mp->id));
            json_object_set_new(ml, "description", json_string(mp->description ? mp->description : ""));
            json_object_set_new(ml, "type", json_string(mp->streaming_type == janus_streaming_type_rtp ? "rtp" : "file"));
            if(mp->streaming_type == janus_streaming_type_rtp) {
                json_object_set_new(ml, "source_ip", json_string(mp->source_ip ? mp->source_ip : "unknown"));
                json_object_set_new(ml, "source_port", json_integer(mp->source_port));
            }
            json_array_append_new(list, ml);
        }
        json_t *root = json_object();
        json_object_set_new(root, "janus", json_string("success"));
        json_object_set_new(root, "streaming", json_string("list"));
        json_object_set_new(root, "list", list);
        /* ... send response unchanged ... */
    }
    /* ... rest of function unchanged ... */
}

/* [Rest of the file unchanged, including all other functions] */